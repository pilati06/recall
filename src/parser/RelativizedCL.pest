// 1. REGRAS DE "SILÊNCIO": Espaços e Comentários
// pest irá consumir isso automaticamente entre as regras
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" | "//" ~ (!"\n" ~ ANY)* }

// 2. REGRA PRINCIPAL (Ponto de Entrada)
// Assumindo que 'contract' é a regra principal.
// SOI = Start of Input, EOI = End of Input
main = { SOI ~ contract ~ EOI }

// 3. REGRAS DO PARSER (Convertidas de 'lowercase' do ANTLR)

contract = { conflict ~ clause ~ (END ~ clause)* ~ END }

// 1. Defina os blocos de forma NÃO-opcional
cfGlobal_block = { GLOBAL ~ "{" ~ cfPair ~ ("," ~ cfPair)* ~ "}" ~ END }
cfRel_block    = { RELATIVIZED ~ "{" ~ cfPair ~ ("," ~ cfPair)* ~ "}" ~ END }

// 2. Crie uma regra "body" que liste as combinações VÁLIDAS.
//    Como "GLOBAL" e "RELATIVIZED" são tokens diferentes, 
//    o parser pode diferenciá-los imediatamente.
conflict_body = {
     (cfGlobal_block ~ cfRel_block?) |  // Começa com Global, pode ou não ter Relativized
     (cfRel_block ~ cfGlobal_block?) |  // Começa com Relativized, pode ou não ter Global
     ""                                 // Ou é vazio
}

// 3. Atualize a regra 'conflict' para usar o 'conflict_body'
//    O '?' externo corresponde à alternativa "/*no conflicts*/" [cite: 7]
conflict = { (CONFLICT ~ "{" ~ conflict_body ~ "}" ~ END)? }

cfPair = { "(" ~ ID ~ "," ~ ID ~ ")" }

// 'clause' era recursiva à esquerda. Foi reescrita usando iteração (*).
clause = { clause_term ~ (AND ~ clause_term)* }
clause_term = {
    co |
    cp |
    cf |
    cd |
    T |
    F |
    "(" ~ clause ~ ")"
}

// 'penalty' era opcional (tinha uma alternativa vazia com código).
// Usamos '?' para torná-la opcional.
penalty = { (OPEN_PTY ~ clause ~ CLOSE_PTY)? }

cd = { rel ~ OPEN_DYN ~ beta ~ CLOSE_DYN ~ (OPEN_EXP ~ clause ~ CLOSE_EXP)? }

// 'co' era recursiva à esquerda.
co = { co_atom ~ (XOR ~ co_atom)* }
co_atom = { rel ~ DEO_O ~ OPEN_EXP ~ alpha ~ CLOSE_EXP ~ penalty }

// 'cp' era recursiva à esquerda.
cp = { cp_atom ~ (XOR ~ cp_atom)* }
cp_atom = { rel ~ DEO_P ~ OPEN_EXP ~ alpha ~ CLOSE_EXP }

// 'cf' era mutuamente recursiva à esquerda.
cf = { cf_term ~ (OR ~ cf_term)* }
cf_term = { cd | cf_atom }
cf_atom = { rel ~ DEO_F ~ OPEN_EXP ~ alpha ~ CLOSE_EXP ~ penalty }

// 'rel' era opcional (tinha alternativa vazia).
// Colocamos as alternativas da mais longa/específica para a mais curta ("").
rel = {
    (OPEN_REL ~ ID ~ SEP_REL ~ ID ~ CLOSE_REL) |
    (OPEN_REL ~ ID ~ CLOSE_REL) |
    ""
}

// 'alpha' era recursiva à esquerda.
alpha = { alpha_atom ~ (op ~ alpha_atom)* }
alpha_atom = { SKIP | VIOLATION | ID | "(" ~ alpha ~ ")" }

// 'beta' era recursiva à esquerda e complexa (prefix, postfix, infix).
// Reescrita com precedência (PEG tenta as regras na ordem).
beta = { beta_term ~ (op ~ beta_term)* }
beta_term = {
    // A ORDEM IMPORTA: As regras mais específicas (com '*') devem vir primeiro.
    UN_OP_NEG ~ "(" ~ ID ~ ")" ~ UN_OP_IT |      // ! (ID)*
    "(" ~ beta ~ ")" ~ UN_OP_IT |      // (beta)*
    ID ~ UN_OP_IT |                   // ID*
    SKIP ~ UN_OP_IT |                 // SKIP*
    VIOLATION ~ UN_OP_IT |            // VIOLATION*
    
    // Regras sem '*'
    ID ~ "." ~ beta |            // ID.beta
    UN_OP_NEG ~ "(" ~ beta ~ ")" |     // !(beta)
    UN_OP_NEG ~ ID |                   // !ID
    "(" ~ beta ~ ")" |           // (beta)
    ID |                         // ID
    SKIP |                       // SKIP
    VIOLATION                    // VIOLATION
}

op = { OP_CHOICE | OP_SEQ | OP_CONC }

// 4. REGRAS DE TOKEN (Convertidas de 'UPPERCASE' do ANTLR)
// Usamos '@' (atômico) para garantir que sejam tokens inteiros
// e não consumam WHITESPACE interno.

CONFLICT    = @{ "conflict" }
GLOBAL      = @{ "global" }
RELATIVIZED = @{ "relativized" }
OPEN_PTY    = @{ "_/" }
CLOSE_PTY   = @{ "/_" }
OPEN_REL    = @{ "{" }
SEP_REL     = @{ "," }
CLOSE_REL   = @{ "}" }
OPEN_EXP    = @{ "(" }
CLOSE_EXP   = @{ ")" }
OPEN_DYN    = @{ "[" }
CLOSE_DYN   = @{ "]" }

DEO_O       = @{ "O" | "_Obliged" }
DEO_P       = @{ "P" | "_Permitted" }
DEO_F       = @{ "F" | "_Prohibited" }
OP_CHOICE   = @{ "+" }
OP_SEQ      = @{ "." }
OP_CONC     = @{ "&" }
UN_OP_IT    = @{ "*" }
UN_OP_NEG   = @{ "!" }
AND         = @{ "^" | "AND" }
OR          = @{ "|" | "OR" }
XOR         = @{ "-" | "XOR" }
T           = @{ "true" }
F           = @{ "false" }
END         = @{ ";" }
SKIP        = @{ "1" }
VIOLATION   = @{ "0" }

// ID e KEYWORD
// Para evitar que "true" seja lido como um ID,
// definimos 'ID' como "qualquer coisa que NÃO seja uma KEYWORD".
KEYWORD = _{
    "conflict" | "global" | "relativized" | "true" | "false" |
    "AND" | "OR" | "XOR" | "_Obliged" | "_Permitted" | "_Prohibited"
}
ID = @{ !KEYWORD ~ ('a'..'z' | 'A'..'Z') ~ ('a'..'z' | 'A'..'Z' | '0'..'9' | "_")* }